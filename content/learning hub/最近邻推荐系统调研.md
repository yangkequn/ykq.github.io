---
title: "Milvus 笔记"
date: 2021-10-06T21:46:16+08:00
draft: false
---

## Milvus:

Python 下的api接口和使用：

https://www.cxyzjd.com/article/sgyuanshi/120049574

Go SDK接口：

https://github.com/milvus-io/milvus-sdk-go

几个基本用法：

https://github.com/milvus-io/milvus-sdk-go/tree/master/examples

2.0.0-rc7版本的docker-compose安装

https://milvus.io/docs/install_standalone-docker.md



## Fasis和Milvus的比较：

[milvus 是集成fasis的，提供了更易使用的接口,知乎](https://zhuanlan.zhihu.com/p/364923722)

fasis更底层，milvus使用更便利 https://medium.com/tokopedia-engineering/how-we-used-semantic-search-to-make-our-search-10x-smarter-bd9c7f601821



# 如何实现推荐功能

1. 如果不存在当前搜索内容，那么搜索主题相关的内容，然后按热度随机排序

如何评估主题内容相关度

$$
\overline{max(Q_i*A_j)} * max(F_i*A_j)
$$
第一部分是评估主题相关性，第二部分是焦点相关性。

2021-11-13

2. 用一个适合milvus 实现的办法，就是把主题矢量和话题矢量串联，作为被检索矢量。同样对于检索矢量，第一部分依然是主题矢量，第二部分是焦点矢量。

   如果是推荐相关，对焦点F做精排序

   如果是推荐尽可能差异大的内容，那么对焦点距离*流行度做二次排序，返回流行度更大，且距离更远的内容

   

3.矢量的更新。

 当用户变更了子话题时，同时更新子话题和主题变量。

   

4. 问题，被检索矢量应该串联主题矢量和焦点矢量，还是应该对着两个矢量取平均值?

 矢量的语义的确是线性可叠加的。可以参考wordvector 平均值法搜索是一个很强的baseline.  但是用（a+b）*(c+D)展开，混同会引入新的两项，a.焦点和被检索主题的乘积，b 被检索话题焦点和当前编辑主题的交叉项。同时削弱主题间的权重和话题间的权重。这个约束会强化结果的准确性。但是会削弱多样性。暂时使用串联。

   

