<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Build websites on To Build, I Live</title><link>https://kequnyang.com/build-website/</link><description>Recent content in Build websites on To Build, I Live</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Fri, 08 Apr 2022 09:43:16 +0800</lastBuildDate><atom:link href="https://kequnyang.com/build-website/index.xml" rel="self" type="application/rss+xml"/><item><title>react 拖拽组件的比较</title><link>https://kequnyang.com/build-website/2022-04-08-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E7%BB%84%E4%BB%B6/</link><pubDate>Fri, 08 Apr 2022 09:43:16 +0800</pubDate><guid>https://kequnyang.com/build-website/2022-04-08-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E7%BB%84%E4%BB%B6/</guid><description> React-js # 优点 # 轻松用起来 缺点 # 需要写大量的保存等逻辑，也不利于后续语义分析 Slate # 优点 # 可以得到InnerHtml 可以切换markdown,HTML等 天然和react 完美集成 更小的体积 对移动端更好的支持 缺点 # 上手难一点，被低级错误卡了两天</description></item><item><title>gitlab ci cd 调研</title><link>https://kequnyang.com/build-website/gitlab-ci-cd-%E8%B0%83%E7%A0%94/</link><pubDate>Tue, 14 Sep 2021 18:34:16 +0800</pubDate><guid>https://kequnyang.com/build-website/gitlab-ci-cd-%E8%B0%83%E7%A0%94/</guid><description>Gitlab-CICD最简单明了的入门教程</description></item><item><title>推荐算法相关问题</title><link>https://kequnyang.com/build-website/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 30 May 2021 18:27:16 +0800</pubDate><guid>https://kequnyang.com/build-website/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid><description>推荐算法有什么功用？ # 推荐算法可以根据用户情况、被推荐条目，向用户推荐内容。换人话，可以根据用户情况，推荐最适合、最感兴趣的知识
那我怎么保证用户学习的内容的多样性？ # 多样性保证应该通过计算，在内容分组之间给出。
那标题还应该存在吗？ # 不，标题不应该存在，管理标题会消耗大量精力 标题可以在内容中被刻意显示。 标题的存在是为了管理聚类。但是聚类，可以用加色块的对话组管理。这是个好的解决方案
怎么服务学习的终极目的 # 终极的学习目的，是持续地长期最大化收获信息熵。具体说来，大致想当于学习更多的条数，以及每个条目内最大成都的有效探索 这个目标，是获得长期的努力最大化，以及单位时间努力的学习效果的最大化。 推荐算法的作用，在于可以保证用户持续不断地推进。获得最大的信息熵增益。每天获得的潜在功效是最大的。
2021-05-30 10:27:23 星期日</description></item><item><title>把AB测试拆分为两个A测试的合理性</title><link>https://kequnyang.com/build-website/%E6%8A%8AAB%E6%B5%8B%E8%AF%95%E6%8B%86%E5%88%86%E4%B8%BA%E4%B8%A4%E4%B8%AAA%E6%B5%8B%E8%AF%95%E7%9A%84%E5%90%88%E7%90%86%E6%80%A7/</link><pubDate>Sat, 29 May 2021 20:02:16 +0800</pubDate><guid>https://kequnyang.com/build-website/%E6%8A%8AAB%E6%B5%8B%E8%AF%95%E6%8B%86%E5%88%86%E4%B8%BA%E4%B8%A4%E4%B8%AAA%E6%B5%8B%E8%AF%95%E7%9A%84%E5%90%88%E7%90%86%E6%80%A7/</guid><description> 是不是可能完成这个拆分（可以独立于其它测试条目，独立地评估一个测试条目的性能） # 性能评估函数若不同时涉及两个条目时。可以做到 就算性能评估函数虽同时涉及两个测试条目的性能数据，但是是对两个数据的再运算。可以做到。 只要把性能评估函数拆分出一个独立地mixin 模块就可以
我暂时没有发现不可以这么做的理由 #</description></item><item><title>日志系统总结</title><link>https://kequnyang.com/build-website/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 29 May 2021 19:43:16 +0800</pubDate><guid>https://kequnyang.com/build-website/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/</guid><description> 日志系统的目的 # 服务AB测试 可以展开大量实验
机器学习应用 构成改进系统性能的控制闭环
用户行为分析
改进对用户的价值
日志系统的要点 # 不要简单实用JSONB, 格式变化太大，不利于后续使用数据。 要有一些必填的数据项，和选填的数据项，来确保一致可使用的数据格式 第一个，提供了系统级的检测和报警。第二个，可以量化整个平台的可靠性。第三个，对日志的格式进行规范，能够尽量减少无效性的数据。第四个，引入实时流处理日志能够实时查询。第五个，开发了日志异常检测服务，可以很快地检测出异常发生的状况。 Airbnb 的核心日志系统架构及主要系统模块的设计之道</description></item><item><title>ab测试调研</title><link>https://kequnyang.com/build-website/ab%E6%B5%8B%E8%AF%95%E8%B0%83%E7%A0%94/</link><pubDate>Sat, 01 May 2021 23:36:16 +0800</pubDate><guid>https://kequnyang.com/build-website/ab%E6%B5%8B%E8%AF%95%E8%B0%83%E7%A0%94/</guid><description> ab测试的方法论 第一大类：频率统计方法 # 它先计算一个t值，并通过t值计算p值。数学含义是，比t值更极端的数值出现的可能性不高于几率p. 频率统计学派并不能回答最常见的问题，P(a比b好) 是多少。 频率统计给出的均值也没啥意义。因为方差的存在，好坏还真是很难讲得清。 好比比尔盖茨国籍上加入瑙鲁，人均财富变得很富有。但是你关心哪种财富分配方式更好。大的均值提高意义也不大。 Bayesian A/B Testing at VWO
ab测试的方法论 第二大类：贝叶斯方法 # 简单地说，贝叶斯方法，就是用信念接受证据，用证据更新信念 进一步说，一般先验可能是任何分布，如果知道的东西越少，那可以假定是均匀分布。但是如果我们有自己的判断，那就可以用自己判断的那种分布。先验一开始课可能出错，但是如果允许反复迭代观察，最终我们的先验总会可以做到接近事实。 从形式来看，我们采用的先验的形式一般写成贝塔分布的形式。然后根据我们的判断，设置其中的a,b参数。之所以采用beta分布，是因为beta 分布既可以接近一种万能的常见分布，又可以简单根据先验，写出后验分布。 参见知乎的讨论 五分钟概率论，写的很棒
贝叶斯决策过程 贝叶斯决策主要包含四个部分： 数据（D）， 假设（W），目标（O），决策（S）。 此处的数据即之前讲到的证据， 假设是我们要验证的事实， 目标是我们最终要取得优化的量， 决策时根据目标得到的最后行为。 与上一步贝叶斯分析增加的部分是目标和决策。假设在问题里如果是连续的往往以参数空间的形式表达。 然后我们可以按照如下步骤做： 第一， 理清因果链条， 哪个是假设， 哪个是证据 第二，给出所有可能假设 ， 即假设空间 第三，给出先验概率 第四，根据贝叶斯概率公式求解后验概率， 得到假设空间的后验概率分布 第五，利用后验概率求解条件期望， 得到条件期望最大值对应的行为 2021-05-01 10:22:38 星期六 代码实现和想法 # python 实现
ab test 应该作为一个无所不在的独立模块使用 ab test 应该提供一个展示的排序方式。来平衡注意力不对等对测试结果的偏差。</description></item><item><title>react 拖拽组件的比较</title><link>https://kequnyang.com/build-website/react-%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/</link><pubDate>Fri, 09 Apr 2021 17:10:16 +0800</pubDate><guid>https://kequnyang.com/build-website/react-%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83/</guid><description> react drag and drop 插件的选择 # ract-dnd # 优点 # 用的人似乎很多 缺点 # 需要指定两个后端 react-sortable-hoc # 优点 # 似乎用起来的接口比较简单 缺点 # 无法为可以被拖动的组件添加事件，提示需要设置为passive event 2021-04-08 花了一天的时间最后在github的issue 上确认了插件没有引入这个特性，暂时是无法解决的问题 react-beautiful-dnd # 缺点 # 文档接口杂乱，demo不能查看对应的源码 优点 # 实际上该有的文档，连视频教程都有 源码和demo的入口位于： https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/about/examples.md 似乎各种后端都能良好支持，如作者所言，抽象度高 能支持键盘操作</description></item><item><title>副本</title><link>https://kequnyang.com/build-website/emptyPage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kequnyang.com/build-website/emptyPage/</guid><description/></item></channel></rss>