<!doctype html><html lang=en dir=" ltr "><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" Method1：平均word-vector法 # 对求句子中所有单词词嵌入的平均值，然后计算两句子词嵌入之间的余弦相似性 参考 中文文本相似度计算
个人觉得，可以用Zipf 假定，对不同的单词向量做调权处理。这样也不用管什么stop words 之类的问题。权重嘛，-*log(p) Methods2: 传统的TF-IDF计算文本相似度 # 分析工具 gensim
优点包括： 1. 速度快 2.可以保存训练好的模型 3.用户多，代码成熟 4.可以训练词向量模型 Method3: Doc2vec法 # Doc2Vec实际上计算除了一个总体语义。总体语义都有了，这意味着很多。 "><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="文本相似度分析"><meta property="og:description" content=" Method1：平均word-vector法 # 对求句子中所有单词词嵌入的平均值，然后计算两句子词嵌入之间的余弦相似性 参考 中文文本相似度计算
个人觉得，可以用Zipf 假定，对不同的单词向量做调权处理。这样也不用管什么stop words 之类的问题。权重嘛，-*log(p) Methods2: 传统的TF-IDF计算文本相似度 # 分析工具 gensim
优点包括： 1. 速度快 2.可以保存训练好的模型 3.用户多，代码成熟 4.可以训练词向量模型 Method3: Doc2vec法 # Doc2Vec实际上计算除了一个总体语义。总体语义都有了，这意味着很多。 "><meta property="og:type" content="article"><meta property="og:url" content="https://kequnyang.com/nlp/%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%88%86%E6%9E%90/"><meta property="article:section" content="nlp"><meta property="article:published_time" content="2021-06-22T19:16:16+08:00"><meta property="article:modified_time" content="2021-06-22T19:16:16+08:00"><title>文本相似度分析 | To Build, I Live</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.dd05bb7cb8e7cc9da19dd8062472a16791465d468ff2c52bf4f137e6d138cbda.css integrity="sha256-3QW7fLjnzJ2hndgGJHKhZ5FGXUaP8sUr9PE35tE4y9o=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.0bf44adf51af0c766073a544559a8bcc48ef7ed5367f2d197352d00da71b4399.js integrity="sha256-C/RK31GvDHZgc6VEVZqLzEjvftU2fy0Zc1LQDacbQ5k=" crossorigin=anonymous></script>
<script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script></head><body dir=" ltr "><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>To Build, I Live</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/forcasts/ target=_blank rel=noopener>forcasts / 预言</a></li><li><a href=/ideas/ target=_blank rel=noopener>ideas / 想法</a></li><li><a href=/okr/2022-10-meditation/ target=_blank rel=noopener>Todo Last Month</a></li><li><a href=/okr/2022-11-meditation/ target=_blank rel=noopener>Todo This Month</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>文本相似度分析</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#method1平均word-vector法>Method1：平均word-vector法</a></li><li><a href=#methods2-传统的tf-idf计算文本相似度>Methods2: 传统的TF-IDF计算文本相似度</a></li><li><a href=#method3-doc2vec法>Method3: Doc2vec法</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h3 id=method1平均word-vector法>Method1：平均word-vector法
<a class=anchor href=#method1%e5%b9%b3%e5%9d%87word-vector%e6%b3%95>#</a></h3><ul><li>对求句子中所有单词词嵌入的平均值，然后计算两句子词嵌入之间的余弦相似性</li></ul><blockquote><p>参考 <a href=https://www.ctolib.com/shibing624-simtext.html title=参考链接>中文文本相似度计算</a></p></blockquote><ul><li>个人觉得，可以用Zipf 假定，对不同的单词向量做调权处理。这样也不用管什么stop words 之类的问题。权重嘛，-*log(p)</li></ul><hr><h3 id=methods2-传统的tf-idf计算文本相似度>Methods2: 传统的TF-IDF计算文本相似度
<a class=anchor href=#methods2-%e4%bc%a0%e7%bb%9f%e7%9a%84tf-idf%e8%ae%a1%e7%ae%97%e6%96%87%e6%9c%ac%e7%9b%b8%e4%bc%bc%e5%ba%a6>#</a></h3><blockquote><p><a href=https://radimrehurek.com/gensim/index.html title=文本相似度分析工具>分析工具 gensim</a></p><ul><li>优点包括： 1. 速度快 2.可以保存训练好的模型 3.用户多，代码成熟 4.可以训练词向量模型</li></ul></blockquote><hr><h3 id=method3-doc2vec法>Method3: Doc2vec法
<a class=anchor href=#method3-doc2vec%e6%b3%95>#</a></h3><ul><li><a href=https://zhuanlan.zhihu.com/p/136096645 title=Doc2Vec>Doc2Vec</a>实际上计算除了一个总体语义。总体语义都有了，这意味着很多。</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#method1平均word-vector法>Method1：平均word-vector法</a></li><li><a href=#methods2-传统的tf-idf计算文本相似度>Methods2: 传统的TF-IDF计算文本相似度</a></li><li><a href=#method3-doc2vec法>Method3: Doc2vec法</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>